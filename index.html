<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Neon Strike - Arène de Combat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <style>
        html, body { margin: 0; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border: 2px solid #00d4ff; border-radius: 10px; pointer-events: none; }
        #login { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content:center; z-index: 100; }
        .box { background: #111; padding: 40px; border: 3px solid #00d4ff; border-radius: 20px; text-align: center; }
        button { padding: 15px 40px; cursor: pointer; font-weight: bold; background: #00d4ff; border: none; border-radius: 5px; font-size: 18px; color: #000; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 14px; height: 14px; border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #msgLog { color: #ff0055; font-weight: bold; font-size: 20px; text-align: center; width: 100%; position: absolute; top: 15%; pointer-events: none; z-index: 50; }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="msgLog"></div>

<div id="login">
    <div class="box">
        <h1 style="color:#00d4ff;">NEON STRIKE</h1>
        <button onclick="connectToCloud()">INITIALISER L'ARÈNE</button>
    </div>
</div>

<div id="ui">
    <div style="color:#00d4ff">SCORE: <span id="myScore">0</span></div>
    <div>ADVERSAIRES: <span id="playerCount">0</span></div>
</div>

<script>
// --- CONFIGURATION ---
const ABLY_KEY = 'hoXqWQ.xS6MJA:4jw_S7dp30pIrB7Sm3tCM6S4WQa57PAqkPdp-WN-Ros'; 
let ably, channel, myID;
let scene, camera, renderer, playerGroup, yaw = 0;
let otherPlayers = {}; 
let bullets = [];
let walls = [];
let keys = {};
let lastSendTime = 0, score = 0;

async function connectToCloud() {
    myID = "user-" + Math.random().toString(36).substr(2, 5);
    try {
        ably = new Ably.Realtime({ key: ABLY_KEY, clientId: myID });
        channel = ably.channels.get('neon-arena-v4');

        channel.subscribe('point', (msg) => {
            const d = msg.data;
            if (d.owner === myID) return;
            if (d.type === 'move') updateRemotePlayer(d);
            else if (d.type === 'fire') createBulletMesh(d);
            else if (d.type === 'kill' && d.target === myID) respawn();
        });

        channel.presence.subscribe('leave', (member) => removePlayer(member.clientId));
        await channel.presence.enter();
        initGame();
    } catch (err) { console.error(err); }
    
    window.addEventListener('beforeunload', () => {
    // On informe Ably qu'on quitte explicitement
    channel.presence.leave();
    ably.close(); 
});
}

function initGame() {
    document.getElementById('login').style.display = 'none';
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020008);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.GridHelper(500, 50, 0x00d4ff, 0x111111));
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));

    // Création des murs de l'arène
    createWall(15, 15, 10, 2);
    createWall(-15, -15, 2, 10);
    createWall(20, -10, 2, 15);
    createWall(-20, 10, 15, 2);

    playerGroup = createPlayerMesh(0x00d4ff);
    scene.add(playerGroup);
    setupControls();
    loop();
}

function createWall(x, z, w, d) {
    const geo = new THREE.BoxGeometry(w, 5, d);
    const mat = new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x00d4ff, emissiveIntensity: 0.2 });
    const wall = new THREE.Mesh(geo, mat);
    wall.position.set(x, 2.5, z);
    scene.add(wall);
    
    // Créer une hitbox simplifiée pour le mur
    walls.push({
        mesh: wall,
        minX: x - w/2 - 0.8, maxX: x + w/2 + 0.8,
        minZ: z - d/2 - 0.8, maxZ: z + d/2 + 0.8
    });
}

function createPlayerMesh(color) {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
    const body = new THREE.Mesh(new THREE.ConeGeometry(0.8, 1.8, 8), mat);
    body.position.y = 0.9;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mat);
    head.position.y = 1.9;
    group.add(body, head);
    return group;
}

function updateRemotePlayer(data) {
    if(!otherPlayers[data.owner]) {
        otherPlayers[data.owner] = { mesh: createPlayerMesh(0xff0055), lastSeen: Date.now() };
        scene.add(otherPlayers[data.owner].mesh);
    }
    const p = otherPlayers[data.owner];
    p.mesh.position.set(data.x, 0, data.z);
    p.mesh.rotation.y = data.yaw;
    p.lastSeen = Date.now();
}

function removePlayer(id) {
    if(otherPlayers[id]) {
        scene.remove(otherPlayers[id].mesh);
        delete otherPlayers[id];
    }
}

function checkWallCollision(newX, newZ) {
    for(let wall of walls) {
        if(newX > wall.minX && newX < wall.maxX && newZ > wall.minZ && newZ < wall.maxZ) return true;
    }
    return false;
}

function shoot() {
    const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const bulletData = { type: 'fire', owner: myID, x: playerGroup.position.x, y: 1.6, z: playerGroup.position.z, dx: dir.x, dz: dir.z };
    channel.publish('point', bulletData);
    createBulletMesh(bulletData);
}

function createBulletMesh(data) {
    const mat = new THREE.MeshBasicMaterial({ color: data.owner === myID ? 0x00ff00 : 0xff0000 });
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), mat);
    mesh.position.set(data.x, data.y, data.z);
    scene.add(mesh);
    bullets.push({ mesh: mesh, dir: new THREE.Vector3(data.dx, 0, data.dz), owner: data.owner, death: Date.now() + 1500 });
}

function loop() {
    requestAnimationFrame(loop);
    const now = Date.now();
    const dt = 0.016;

    // Déplacement avec collision murale
    const nextPos = playerGroup.position.clone();
    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyS']) move.sub(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyA']) move.add(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));
    if(keys['KeyD']) move.sub(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));

    if(move.length() > 0) {
        const step = move.normalize().multiplyScalar(24 * dt);
        if(!checkWallCollision(playerGroup.position.x + step.x, playerGroup.position.z)) playerGroup.position.x += step.x;
        if(!checkWallCollision(playerGroup.position.x, playerGroup.position.z + step.z)) playerGroup.position.z += step.z;
    }
    playerGroup.rotation.y = yaw;

    // Réseau
    if(now - lastSendTime > 100) {
        channel.publish('point', { type: 'move', owner: myID, x: playerGroup.position.x, z: playerGroup.position.z, yaw: yaw });
        lastSendTime = now;
    }

    // Balles et impacts
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.dir, 80 * dt);

        // Collision balle vs Mur
        if(checkWallCollision(b.mesh.position.x, b.mesh.position.z)) {
            scene.remove(b.mesh); bullets.splice(i, 1); continue;
        }

        // Collision balle vs Joueur
        if (b.owner === myID) {
            for (let id in otherPlayers) {
                if (b.mesh.position.distanceTo(otherPlayers[id].mesh.position) < 2.0) {
                    channel.publish('point', { type: 'kill', owner: myID, target: id });
                    score++; document.getElementById('myScore').textContent = score;
                    scene.remove(b.mesh); bullets.splice(i, 1); break;
                }
            }
        }
        if (bullets[i] && now > b.death) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    camera.position.set(playerGroup.position.x - Math.sin(yaw)*14, 7, playerGroup.position.z - Math.cos(yaw)*14);
    camera.lookAt(playerGroup.position);
    document.getElementById('playerCount').textContent = Object.keys(otherPlayers).length;
    renderer.render(scene, camera);
}

function respawn() {
    playerGroup.position.set(Math.random()*10-5, 0, Math.random()*10-5);
    const log = document.getElementById('msgLog');
    log.textContent = "ÉLIMINÉ !";
    setTimeout(() => log.textContent = "", 2000);
}

function setupControls() {
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });
    window.addEventListener('mousedown', () => { 
        if(document.pointerLockElement) shoot(); 
        else renderer.domElement.requestPointerLock().catch(()=>{});
    });
}
</script>
</body>
</html>


<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
   <title>Neon Strike | Jeu de Tir Multijoueur Online</title>
<meta name="description" content="Affronte tes amis dans Neon Strike, le jeu de tir frénétique par navigateur. Pas d'installation, joue directement en ligne dans l'arène néon !">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <style>
        html, body { margin: 0; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border: 2px solid #00d4ff; border-radius: 10px; pointer-events: none; z-index: 10; }
        #health-container { width: 200px; height: 15px; background: #333; border: 1px solid #fff; margin-top: 10px; }
        #health-bar { width: 100%; height: 100%; background: #ff0055; transition: width 0.3s; }
        #login { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content:center; z-index: 100; }
        .box { background: #111; padding: 40px; border: 3px solid #00d4ff; border-radius: 20px; text-align: center; }
        button { padding: 15px 40px; cursor: pointer; font-weight: bold; background: #00d4ff; border: none; border-radius: 5px; font-size: 18px; color: #000; text-transform: uppercase; }
        #msgLog { color: #ff0055; font-weight: bold; font-size: 24px; text-align: center; width: 100%; position: absolute; top: 15%; pointer-events: none; z-index: 50; }
    </style>
    <meta name="description" content="Neon Strike : un jeu de tir multijoueur frénétique dans une arène néon. Affrontez vos amis en ligne gratuitement !">
<meta name="keywords" content="jeu en ligne, multijoueur, browser game, shooter, néon, three.js">
<meta property="og:title" content="Neon Strike - Arène de Combat Online">
<meta property="og:description" content="Rejoins l'arène et deviens le champion du néon.">
<meta name="google-site-verification" content="1jk5iL5mJ3ySz3eU4zRGVjjcUTF2W31MSwGfpRCq3Zs" />
</head>
<body>

<div id="msgLog"></div>

<div id="login">
    <div class="box">
        <h1 style="color:#00d4ff; letter-spacing: 5px;">NEON STRIKE</h1>
        <p id="keyStatus" style="color: #555; font-size: 12px;">En attente d'initialisation...</p>
        <button onclick="connectToCloud()">ENTRER DANS L'ARÈNE</button>
    </div>
</div>

<div id="ui">
    <div style="color:#00d4ff">SCORE: <span id="myScore">0</span></div>
    <div>JOUEURS: <span id="playerCount">0</span></div>
    <div>CLÉ: <span id="activeKey">1</span></div>
    <div id="health-container"><div id="health-bar"></div></div>
</div>

<script>
// --- CONFIGURATION ---
const KEYS = [
    'hoXqWQ.xS6MJA:4jw_S7dp30pIrB7Sm3tCM6S4WQa57PAqkPdp-WN-Ros',
    'VxkiKg.ll3U8g:y10rnnVr2hatHn4iYPs6FGt_Ei3V1WkmoJoZIyEcwCo'
];
let currentKeyIndex = 0;
let ably, channel, myID;
let scene, camera, renderer, playerGroup, yaw = 0;
let otherPlayers = {}; 
let bullets = [], walls = [], keys = {};
let lastSendTime = 0, score = 0, hp = 100;

async function connectToCloud() {
    myID = "u-" + Math.random().toString(36).substr(2, 4);
    const statusEl = document.getElementById('keyStatus');
    if(statusEl) statusEl.textContent = "Connexion sur Clé #" + (currentKeyIndex + 1) + "...";
    
    try {
        ably = new Ably.Realtime({ key: KEYS[currentKeyIndex], clientId: myID });
        
        ably.connection.on('failed', () => switchToNextKey());
        
        channel = ably.channels.get('neon-arena-v6');

        channel.subscribe('p', (msg) => {
            const d = msg.data;
            if (d.o === myID) return;
            if (d.t === 'm') updateRemotePlayer(d);
            else if (d.t === 'f') createBulletMesh(d);
            else if (d.t === 'h' && d.tgt === myID) takeDamage(34);
        });

        channel.presence.subscribe('leave', (m) => removePlayer(m.clientId));
        await channel.presence.enter();

        const keyEl = document.getElementById('activeKey');
        if(keyEl) keyEl.textContent = (currentKeyIndex + 1);
        
        initGame();
        
        window.addEventListener('beforeunload', () => {
            if(channel) channel.presence.leave();
            if(ably) ably.close();
        });
    } catch (err) { 
        console.error(err);
        switchToNextKey(); 
    }
}

function switchToNextKey() {
    currentKeyIndex++;
    if (currentKeyIndex < KEYS.length) {
        if(ably) ably.close();
        connectToCloud();
    } else {
        alert("Quota épuisé sur toutes les clés Ably.");
    }
}

function initGame() {
    const loginScreen = document.getElementById('login');
    if(loginScreen) loginScreen.style.display = 'none';
    if(scene) return;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020008);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.GridHelper(500, 100, 0x00d4ff, 0x111111));
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));

    // MURS DE BORDURE
    createWall(0, 100, 200, 2);
    createWall(0, -100, 200, 2);
    createWall(100, 0, 2, 200);
    createWall(-100, 0, 2, 200);

    // MURS INTERIEURS (Labyrinthe)
    for(let i = 0; i < 30; i++) {
        let x = Math.random() * 160 - 80;
        let z = Math.random() * 160 - 80;
        if(Math.abs(x) > 15 || Math.abs(z) > 15) {
            let isWide = Math.random() > 0.5;
            createWall(x, z, isWide ? 20 : 2, isWide ? 2 : 20);
        }
    }

    playerGroup = createPlayerMesh(0x00d4ff);
    scene.add(playerGroup);
    setupControls();
    loop();
}

function createWall(x, z, w, d) {
    const geo = new THREE.BoxGeometry(w, 7, d);
    const wall = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x00d4ff, emissive: 0x00d4ff, emissiveIntensity: 0.2 }));
    wall.position.set(x, 3.5, z);
    scene.add(wall);
    walls.push({ minX: x - w/2 - 0.9, maxX: x + w/2 + 0.9, minZ: z - d/2 - 0.9, maxZ: z + d/2 + 0.9 });
}

function createPlayerMesh(color) {
    const g = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
    const body = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2, 8), mat);
    body.position.y = 1;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mat);
    head.position.y = 2.2;
    g.add(body, head);
    return g;
}

function updateRemotePlayer(d) {
    if(!otherPlayers[d.o]) {
        otherPlayers[d.o] = { mesh: createPlayerMesh(0xff0055), lastSeen: Date.now() };
        scene.add(otherPlayers[d.o].mesh);
    }
    const p = otherPlayers[d.o];
    p.mesh.position.set(d.x, 0, d.z);
    p.mesh.rotation.y = d.y;
    p.lastSeen = Date.now();
}

function removePlayer(id) {
    if(otherPlayers[id]) { scene.remove(otherPlayers[id].mesh); delete otherPlayers[id]; }
}

function takeDamage(amt) {
    hp -= amt;
    const bar = document.getElementById('health-bar');
    if(bar) bar.style.width = Math.max(0, hp) + "%";
    if(hp <= 0) respawn();
}

function respawn() {
    hp = 100;
    const bar = document.getElementById('health-bar');
    if(bar) bar.style.width = "100%";

    // On cherche une position libre (pas dans un mur)
    let safeX, safeZ;
    let attempts = 0;
    
    do {
        // On choisit une position entre -90 et 90 (l'arène fait -100 à 100)
        safeX = Math.random() * 180 - 90;
        safeZ = Math.random() * 180 - 90;
        attempts++;
    } while (checkWall(safeX, safeZ) && attempts < 10); // On recommence si c'est un mur

    playerGroup.position.set(safeX, 0, safeZ);
    
    const log = document.getElementById('msgLog');
    if(log) {
        log.textContent = "REPLOIEMENT TACTIQUE...";
        setTimeout(() => log.textContent = "", 2000);
    }
}

function loop() {
    requestAnimationFrame(loop);
    if(!scene) return;
    const now = Date.now();
    const dt = 0.016;

    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyS']) move.sub(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyA']) move.add(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));
    if(keys['KeyD']) move.sub(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));

    if(move.length() > 0) {
        const step = move.normalize().multiplyScalar(30 * dt);
        if(!checkWall(playerGroup.position.x + step.x, playerGroup.position.z)) playerGroup.position.x += step.x;
        if(!checkWall(playerGroup.position.x, playerGroup.position.z + step.z)) playerGroup.position.z += step.z;
    }
    playerGroup.rotation.y = yaw;

    if(now - lastSendTime > 120) {
        channel.publish('p', { t: 'm', o: myID, x: playerGroup.position.x, z: playerGroup.position.z, y: yaw });
        lastSendTime = now;
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.dir, 90 * dt);
        if(checkWall(b.mesh.position.x, b.mesh.position.z)) { scene.remove(b.mesh); bullets.splice(i, 1); continue; }
        if (b.o === myID) {
            for (let id in otherPlayers) {
                if (b.mesh.position.distanceTo(otherPlayers[id].mesh.position) < 2.2) {
                    channel.publish('p', { t: 'h', o: myID, tgt: id });
                    scene.remove(b.mesh); bullets.splice(i, 1); break;
                }
            }
        }
        if (bullets[i] && now > b.death) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    camera.position.set(playerGroup.position.x - Math.sin(yaw)*16, 9, playerGroup.position.z - Math.cos(yaw)*16);
    camera.lookAt(playerGroup.position);
    
    // SECURITE : Vérifier si l'élément existe avant d'écrire
    const pCountEl = document.getElementById('playerCount');
    if(pCountEl) pCountEl.textContent = Object.keys(otherPlayers).length;
    
    renderer.render(scene, camera);
}

function checkWall(x, z) {
    for(let w of walls) { if(x > w.minX && x < w.maxX && z > w.minZ && z < w.maxZ) return true; }
    return false;
}

function shoot() {
    const d = { t: 'f', o: myID, x: playerGroup.position.x, y: 1.8, z: playerGroup.position.z, dx: Math.sin(yaw), dz: Math.cos(yaw) };
    channel.publish('p', d);
    createBulletMesh(d);
}

function createBulletMesh(d) {
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({ color: d.o === myID ? 0x00ff00 : 0xff0000 }));
    mesh.position.set(d.x, d.y, d.z);
    scene.add(mesh);
    bullets.push({ mesh: mesh, dir: new THREE.Vector3(d.dx, 0, d.dz), o: d.o, death: Date.now() + 2000 });
}

function setupControls() {
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });
    window.addEventListener('mousedown', () => { 
        if(document.pointerLockElement) shoot(); 
        else renderer.domElement.requestPointerLock().catch(()=>{}); 
    });
}
</script>
</body>
</html>









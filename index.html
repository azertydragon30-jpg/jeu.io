<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Neon Strike - Multi-Key Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <style>
        html, body { margin: 0; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border: 2px solid #00d4ff; border-radius: 10px; pointer-events: none; }
        #health-container { width: 200px; height: 15px; background: #333; border: 1px solid #fff; margin-top: 10px; }
        #health-bar { width: 100%; height: 100%; background: #ff0055; transition: width 0.3s; }
        #login { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content:center; z-index: 100; }
        .box { background: #111; padding: 40px; border: 3px solid #00d4ff; border-radius: 20px; text-align: center; }
        button { padding: 15px 40px; cursor: pointer; font-weight: bold; background: #00d4ff; border: none; border-radius: 5px; font-size: 18px; color: #000; }
        #msgLog { color: #ff0055; font-weight: bold; font-size: 24px; text-align: center; width: 100%; position: absolute; top: 15%; pointer-events: none; }
    </style>
</head>
<body>

<div id="msgLog"></div>
<div id="login">
    <div class="box">
        <h1 style="color:#00d4ff;">NEON STRIKE</h1>
        <p id="keyStatus" style="font-size: 10px; color: #555;">Initialisation des clés...</p>
        <button onclick="connectToCloud()">LANCER LE JEU</button>
    </div>
</div>

<div id="ui">
    <div style="color:#00d4ff">SCORE: <span id="myScore">0</span></div>
    <div>CLÉ ACTIVE: <span id="activeKey">1</span></div>
    <div id="health-container"><div id="health-bar"></div></div>
</div>

<script>
// --- CONFIGURATION MULTI-CLÉS ---
const KEYS = [
    'hoXqWQ.xS6MJA:4jw_S7dp30pIrB7Sm3tCM6S4WQa57PAqkPdp-WN-Ros',
    'VxkiKg.ll3U8g:y10rnnVr2hatHn4iYPs6FGt_Ei3V1WkmoJoZIyEcwCo'
];
let currentKeyIndex = 0;

let ably, channel, myID;
let scene, camera, renderer, playerGroup, yaw = 0;
let otherPlayers = {}; 
let bullets = [], walls = [], keys = {};
let lastSendTime = 0, score = 0, hp = 100;

async function connectToCloud() {
    myID = "u-" + Math.random().toString(36).substr(2, 4);
    document.getElementById('keyStatus').textContent = "Connexion Clé #" + (currentKeyIndex + 1) + "...";
    
    try {
        ably = new Ably.Realtime({ key: KEYS[currentKeyIndex], clientId: myID });
        ably.connection.on('failed', () => switchToNextKey());
        
        channel = ably.channels.get('neon-arena-large');

        channel.subscribe('p', (msg) => {
            const d = msg.data;
            if (d.o === myID) return;
            if (d.t === 'm') updateRemotePlayer(d);
            else if (d.t === 'f') createBulletMesh(d);
            else if (d.t === 'h' && d.tgt === myID) takeDamage(34);
        });

        channel.presence.subscribe('leave', (m) => removePlayer(m.clientId));
        await channel.presence.enter();

        document.getElementById('activeKey').textContent = (currentKeyIndex + 1);
        initGame();
        
        window.addEventListener('beforeunload', () => {
            channel.presence.leave();
            ably.close();
        });
    } catch (err) { switchToNextKey(); }
}

function switchToNextKey() {
    currentKeyIndex++;
    if (currentKeyIndex < KEYS.length) {
        if(ably) ably.close();
        connectToCloud();
    } else {
        alert("Toutes les clés sont saturées !");
    }
}

function initGame() {
    document.getElementById('login').style.display = 'none';
    if(scene) return;

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020008);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Sol géant
    scene.add(new THREE.GridHelper(400, 80, 0x00d4ff, 0x111111));
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));

    // --- CONSTRUCTION DE L'ARÈNE ---
    // 1. Murs de bordure (Limites du monde)
    createWall(0, 80, 160, 2);  // Nord
    createWall(0, -80, 160, 2); // Sud
    createWall(80, 0, 2, 160);  // Est
    createWall(-80, 0, 2, 160); // Ouest

    // 2. Obstacles intérieurs (Labyrinthe)
    for(let i = 0; i < 25; i++) {
        let rx = Math.floor(Math.random() * 120 - 60);
        let rz = Math.floor(Math.random() * 120 - 60);
        let rw = Math.random() > 0.5 ? 15 : 2;
        let rd = rw === 15 ? 2 : 15;
        
        // On évite de poser un mur trop près du centre (spawn)
        if(Math.abs(rx) > 10 || Math.abs(rz) > 10) {
            createWall(rx, rz, rw, rd);
        }
    }

    playerGroup = createPlayerMesh(0x00d4ff);
    scene.add(playerGroup);
    setupControls();
    loop();
}

function createWall(x, z, w, d) {
    const geo = new THREE.BoxGeometry(w, 6, d);
    const wall = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
        color: 0x00d4ff, 
        emissive: 0x00d4ff, 
        emissiveIntensity: 0.3 
    }));
    wall.position.set(x, 3, z);
    scene.add(wall);
    walls.push({ minX: x - w/2 - 0.9, maxX: x + w/2 + 0.9, minZ: z - d/2 - 0.9, maxZ: z + d/2 + 0.9 });
}

function createPlayerMesh(color) {
    const g = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
    g.add(new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.0, 8), mat));
    const h = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), mat);
    h.position.y = 2.1;
    g.add(h);
    return g;
}

function updateRemotePlayer(d) {
    if(!otherPlayers[d.o]) {
        otherPlayers[d.o] = { mesh: createPlayerMesh(0xff0055), lastSeen: Date.now() };
        scene.add(otherPlayers[d.o].mesh);
    }
    const p = otherPlayers[d.o];
    p.mesh.position.set(d.x, 1.0, d.z);
    p.mesh.rotation.y = d.y;
    p.lastSeen = Date.now();
}

function removePlayer(id) {
    if(otherPlayers[id]) { scene.remove(otherPlayers[id].mesh); delete otherPlayers[id]; }
}

function takeDamage(amt) {
    hp -= amt;
    document.getElementById('health-bar').style.width = Math.max(0, hp) + "%";
    if(hp <= 0) respawn();
}

function respawn() {
    hp = 100;
    document.getElementById('health-bar').style.width = "100%";
    playerGroup.position.set(Math.random()*10-5, 0, Math.random()*10-5);
    document.getElementById('msgLog').textContent = "ÉLIMINÉ !";
    setTimeout(() => document.getElementById('msgLog').textContent = "", 2000);
}

function shoot() {
    const d = { t: 'f', o: myID, x: playerGroup.position.x, y: 1.6, z: playerGroup.position.z, dx: Math.sin(yaw), dz: Math.cos(yaw) };
    channel.publish('p', d);
    createBulletMesh(d);
}

function createBulletMesh(d) {
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), new THREE.MeshBasicMaterial({ color: d.o === myID ? 0x00ff00 : 0xff0000 }));
    mesh.position.set(d.x, d.y, d.z);
    scene.add(mesh);
    bullets.push({ mesh: mesh, dir: new THREE.Vector3(d.dx, 0, d.dz), o: d.o, death: Date.now() + 2000 });
}

function loop() {
    requestAnimationFrame(loop);
    const now = Date.now();
    const dt = 0.016;

    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyS']) move.sub(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyA']) move.add(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));
    if(keys['KeyD']) move.sub(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));

    if(move.length() > 0) {
        const step = move.normalize().multiplyScalar(28 * dt);
        if(!checkWall(playerGroup.position.x + step.x, playerGroup.position.z)) playerGroup.position.x += step.x;
        if(!checkWall(playerGroup.position.x, playerGroup.position.z + step.z)) playerGroup.position.z += step.z;
    }
    playerGroup.rotation.y = yaw;

    if(now - lastSendTime > 120) {
        channel.publish('p', { t: 'm', o: myID, x: playerGroup.position.x, z: playerGroup.position.z, y: yaw });
        lastSendTime = now;
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.dir, 95 * dt);
        if(checkWall(b.mesh.position.x, b.mesh.position.z)) { scene.remove(b.mesh); bullets.splice(i, 1); continue; }
        if (b.o === myID) {
            for (let id in otherPlayers) {
                if (b.mesh.position.distanceTo(otherPlayers[id].mesh.position) < 2.2) {
                    channel.publish('p', { t: 'h', o: myID, tgt: id });
                    scene.remove(b.mesh); bullets.splice(i, 1); break;
                }
            }
        }
        if (bullets[i] && now > b.death) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    camera.position.set(playerGroup.position.x - Math.sin(yaw)*16, 9, playerGroup.position.z - Math.cos(yaw)*16);
    camera.lookAt(playerGroup.position);
    document.getElementById('playerCount').textContent = Object.keys(otherPlayers).length;
    renderer.render(scene, camera);
}

function checkWall(x, z) {
    for(let w of walls) { if(x > w.minX && x < w.maxX && z > w.minZ && z < w.maxZ) return true; }
    return false;
}

function setupControls() {
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });
    window.addEventListener('mousedown', () => { if(document.pointerLockElement) shoot(); else renderer.domElement.requestPointerLock().catch(()=>{}); });
}
</script>
</body>
</html>




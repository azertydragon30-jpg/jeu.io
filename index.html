<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Neon Strike - Combat Final</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
    <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
    <style>
        html, body { margin: 0; height: 100%; overflow: hidden; background: #000; color: #fff; font-family: 'Courier New', monospace; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border: 2px solid #00d4ff; border-radius: 10px; pointer-events: none; }
        #login { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content:center; z-index: 100; }
        .box { background: #111; padding: 40px; border: 3px solid #00d4ff; border-radius: 20px; text-align: center; }
        button { padding: 15px 40px; cursor: pointer; font-weight: bold; background: #00d4ff; border: none; border-radius: 5px; font-size: 18px; color: #000; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 14px; height: 14px; border: 2px solid #00ff00; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        #msgLog { color: #ff0055; font-weight: bold; font-size: 20px; text-align: center; width: 100%; position: absolute; top: 20%; pointer-events: none; }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="msgLog"></div>

<div id="login">
    <div class="box">
        <h1 style="color:#00d4ff;">NEON STRIKE</h1>
        <button onclick="connectToCloud()">ENTRER DANS L'ARÈNE</button>
    </div>
</div>

<div id="ui">
    <div style="color:#00d4ff">SCORE: <span id="myScore">0</span></div>
    <div>ADVERSAIRES: <span id="playerCount">0</span></div>
</div>

<script>// --- CONFIGURATION ---
const ABLY_KEY = 'hoXqWQ.xS6MJA:4jw_S7dp30pIrB7Sm3tCM6S4WQa57PAqkPdp-WN-Ros'; 
let ably, channel, myID;
let scene, camera, renderer, playerGroup, yaw = 0;
let otherPlayers = {}; 
let bullets = [];
let keys = {};
let lastSendTime = 0, lastYaw = 0, score = 0;

const BULLET_SPEED = 70; // Légèrement réduit pour plus de précision

async function connectToCloud() {
    myID = "user-" + Math.random().toString(36).substr(2, 5);
    try {
        ably = new Ably.Realtime({ key: ABLY_KEY, clientId: myID });
        channel = ably.channels.get('neon-arena-final');

        channel.subscribe('point', (msg) => {
            const d = msg.data;
            if (d.owner === myID) return;

            if (d.type === 'move') updateRemotePlayer(d);
            else if (d.type === 'fire') createBulletMesh(d);
            else if (d.type === 'kill' && d.target === myID) {
                console.log("INFO: Tu as été touché par " + d.owner);
                respawn();
            }
        });

        channel.presence.subscribe('leave', (member) => removePlayer(member.clientId));
        await channel.presence.enter();
        initGame();
    } catch (err) { console.error(err); }
}

function initGame() {
    document.getElementById('login').style.display = 'none';
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020008);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.GridHelper(1000, 100, 0x00d4ff, 0x111111));
    scene.add(new THREE.AmbientLight(0xffffff, 0.9));

    playerGroup = createPlayerMesh(0x00d4ff);
    scene.add(playerGroup);
    setupControls();
    loop();
}

function createPlayerMesh(color) {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
    const body = new THREE.Mesh(new THREE.ConeGeometry(1.0, 2.0, 8), mat); // Corps un peu plus gros
    body.position.y = 1.0;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), mat);
    head.position.y = 2.1;
    group.add(body, head);
    return group;
}

function updateRemotePlayer(data) {
    if(!otherPlayers[data.owner]) {
        otherPlayers[data.owner] = { mesh: createPlayerMesh(0xff0055), lastSeen: Date.now() };
        scene.add(otherPlayers[data.owner].mesh);
    }
    const p = otherPlayers[data.owner];
    p.mesh.position.set(data.x, 0, data.z); // Position directe pour éviter le lag de l'interpolation pendant les tests
    p.mesh.rotation.y = data.yaw;
    p.lastSeen = Date.now();
}

function removePlayer(id) {
    if(otherPlayers[id]) {
        scene.remove(otherPlayers[id].mesh);
        delete otherPlayers[id];
    }
}

function shoot() {
    const dir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const bulletData = { 
        type: 'fire', 
        owner: myID, 
        x: playerGroup.position.x, 
        y: 1.6, 
        z: playerGroup.position.z, 
        dx: dir.x, 
        dz: dir.z 
    };
    channel.publish('point', bulletData);
    createBulletMesh(bulletData);
}

function createBulletMesh(data) {
    const mat = new THREE.MeshBasicMaterial({ color: data.owner === myID ? 0x00ff00 : 0xff0000 });
    const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), mat); // Balle plus grosse
    mesh.position.set(data.x, data.y, data.z);
    scene.add(mesh);
    bullets.push({ mesh: mesh, dir: new THREE.Vector3(data.dx, 0, data.dz), owner: data.owner, death: Date.now() + 1500 });
}

function loop() {
    requestAnimationFrame(loop);
    const now = Date.now();
    const dt = 0.016;

    const move = new THREE.Vector3();
    if(keys['KeyW']) move.add(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyS']) move.sub(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
    if(keys['KeyA']) move.add(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));
    if(keys['KeyD']) move.sub(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));
    if(move.length() > 0) playerGroup.position.addScaledVector(move.normalize(), 24 * dt);
    playerGroup.rotation.y = yaw;

    if((move.length() > 0 || Math.abs(lastYaw - yaw) > 0.01) && (now - lastSendTime > 80)) {
        channel.publish('point', { type: 'move', owner: myID, x: playerGroup.position.x, z: playerGroup.position.z, yaw: yaw });
        lastSendTime = now; lastYaw = yaw;
    }

    // --- DETECTION DE COLLISION AMÉLIORÉE ---
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.mesh.position.addScaledVector(b.dir, BULLET_SPEED * dt);

        if (b.owner === myID) {
            for (let id in otherPlayers) {
                // Distance de collision augmentée à 2.2 pour être sûr
                if (b.mesh.position.distanceTo(otherPlayers[id].mesh.position) < 2.2) {
                    console.log("TOUCHE ! Envoi du signal de mort à " + id);
                    channel.publish('point', { type: 'kill', owner: myID, target: id });
                    score++;
                    document.getElementById('myScore').textContent = score;
                    scene.remove(b.mesh); bullets.splice(i, 1); break;
                }
            }
        }
        if (bullets[i] && now > b.death) { scene.remove(b.mesh); bullets.splice(i, 1); }
    }

    for (let id in otherPlayers) { if (now - otherPlayers[id].lastSeen > 5000) removePlayer(id); }

    camera.position.set(playerGroup.position.x - Math.sin(yaw)*14, 7, playerGroup.position.z - Math.cos(yaw)*14);
    camera.lookAt(playerGroup.position);
    document.getElementById('playerCount').textContent = Object.keys(otherPlayers).length;
    renderer.render(scene, camera);
}

function respawn() {
    playerGroup.position.set(Math.random()*40-20, 0, Math.random()*40-20);
    const log = document.getElementById('msgLog');
    log.textContent = "TU AS ÉTÉ ÉLIMINÉ !";
    setTimeout(() => log.textContent = "", 2000);
}

function setupControls() {
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });
    window.addEventListener('mousedown', () => { 
        if(document.pointerLockElement) shoot(); 
        else renderer.domElement.requestPointerLock().catch(()=>{});
    });
}
</script>
</body>
</html>




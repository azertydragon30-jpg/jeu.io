<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Neon Strike - MULTI PLAYROOM</title>
    <script src="https://unpkg.com/playroomkit/multiplayer.js"></script>
    <style>
        html, body { margin: 0; height: 100%; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; }
        .ui-overlay {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; background: rgba(0,0,0,0.7); padding: 15px;
            border-radius: 10px; border: 1px solid #00d4ff; pointer-events: none;
        }
        #weaponHUD {
            position: absolute; bottom: 20px; right: 20px; color: #ffdd33;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px;
            border: 2px solid #ffdd33; font-weight: bold; font-size: 18px;
        }
    </style>
</head>
<body>

<div class="ui-overlay">
    <div id="status">Connexion au salon...</div>
    <div id="playerList">Joueurs: 1/10</div>
    <div id="scoreHUD">Points: 0</div>
</div>

<div id="weaponHUD">PISTOLET</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js";

// --- CONFIGURATION PLAYROOM ---
const { insertCoin, myPlayer, onPlayerJoin, isHost } = Playroom;

let scene, camera, renderer, yaw = 0;
let players = []; // Liste des états des joueurs
let playerMeshes = {}; // ID -> Mesh Three.js
let keys = {};

const SKINS = {
    default: { color: 0x00d4ff },
    coneHead: { color: 0xff00ff },
    tank: { color: 0x00ff88 }
};

// --- INITIALISATION ---

async function start() {
    // 1. Lancement du multijoueur (interface de lobby automatique)
    await insertCoin({
        gameId: "neon-strike-v7", // ID unique pour ton jeu
        maxPlayersPerRoom: 10,
    });

    setupScene();

    // 2. Gestion des joueurs qui rejoignent
    onPlayerJoin((state) => {
        const id = state.id;
        const color = state.getProfile().color.hex;
        
        // Création du personnage pour ce joueur
        const group = new THREE.Group();
        buildPlayerMesh(group, state.getCustomProperty("skin") || "default", color);
        scene.add(group);
        
        playerMeshes[id] = group;
        players.push(state);

        // Si le joueur quitte
        state.onQuit(() => {
            scene.remove(playerMeshes[id]);
            delete playerMeshes[id];
        });
    });

    setupEvents();
    loop();
}

function buildPlayerMesh(group, skinKey, color) {
    while(group.children.length > 0) group.remove(group.children[0]);
    const mat = new THREE.MeshStandardMaterial({color: color, emissive: color, emissiveIntensity: 0.5});
    
    if(skinKey === 'coneHead') {
        const b = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.4, 8), mat);
        const h = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), mat);
        h.position.y = 0.8; group.add(b, h);
    } else {
        group.add(new THREE.Mesh(new THREE.CapsuleGeometry(0.6, 1, 4, 8), mat));
    }
}

function setupScene() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020005);
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.GridHelper(500, 100, 0x4400ff, 0x111111));
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
}

function loop() {
    requestAnimationFrame(loop);
    const dt = 0.016;
    const me = myPlayer();

    // 1. Logique Joueur Local
    if(me) {
        const myMesh = playerMeshes[me.id];
        if(myMesh) {
            const move = new THREE.Vector3();
            if(keys['KeyW']) move.add(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
            if(keys['KeyS']) move.sub(new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)));
            if(keys['KeyA']) move.add(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));
            if(keys['KeyD']) move.sub(new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw)));

            if(move.length() > 0) {
                myMesh.position.addScaledVector(move.normalize(), 20 * dt);
            }
            myMesh.rotation.y = yaw;

            // ENVOI DE LA POSITION AU SERVEUR PLAYROOM
            me.setState("pos", { x: myMesh.position.x, z: myMesh.position.z });
            me.setState("yaw", yaw);

            // Placement caméra
            camera.position.set(myMesh.position.x - Math.sin(yaw)*15, 8, myMesh.position.z - Math.cos(yaw)*15);
            camera.lookAt(myMesh.position);
        }
    }

    // 2. Synchronisation des autres joueurs
    players.forEach(state => {
        if(state.id === me.id) return; // Ne pas se synchroniser soi-même
        
        const mesh = playerMeshes[state.id];
        const pos = state.getState("pos");
        const rYaw = state.getState("yaw");

        if(mesh && pos) {
            // Interpolation douce (lerp) pour éviter les saccades
            mesh.position.x = THREE.MathUtils.lerp(mesh.position.x, pos.x, 0.2);
            mesh.position.z = THREE.MathUtils.lerp(mesh.position.z, pos.z, 0.2);
            mesh.rotation.y = rYaw || 0;
        }
    });

    document.getElementById('playerList').textContent = `Joueurs: ${players.length}/10`;
    renderer.render(scene, camera);
}

function setupEvents() {
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        // Changement de skin local pour tester (on pourrait le mettre en boutique plus tard)
        if(e.key === 'k') { 
            const newSkin = "coneHead";
            myPlayer().setState("skin", newSkin); 
            buildPlayerMesh(playerMeshes[myPlayer().id], newSkin, myPlayer().getProfile().color.hex);
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);
    document.addEventListener('mousemove', e => { if(document.pointerLockElement) yaw -= e.movementX * 0.003; });
    window.addEventListener('mousedown', () => renderer.domElement.requestPointerLock());
}

// Lancement !
start();
</script>
</body>
</html>
